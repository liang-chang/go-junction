package junction

import (
	"directory"
	//	"fmt"
	//	"regexp"
	//"log"
	//	"os"
	//	"os/exec"
	//	"path/filepath"
	//	"strings"
	//	"bytes"
	//	"strings"
	//	"bytes"
	//	"path/filepath"
	//	"os"
	//	"log"
	//"io/ioutil"
	//"fmt"

	"os"
	"fmt"
	"syscall"
	"unsafe"
	"path/filepath"
	"encoding/binary"
	"strings"
	"bytes"
	"strconv"
)

/// <summary>
/// The file or directory is not a reparse point.
/// </summary>
const ERROR_NOT_A_REPARSE_POINT = 4390;

/// <summary>
/// The reparse point attribute cannot be set because it conflicts with an existing attribute.
/// </summary>
const ERROR_REPARSE_ATTRIBUTE_CONFLICT = 4391;

/// <summary>
/// The data present in the reparse point buffer is invalid.
/// </summary>
const ERROR_INVALID_REPARSE_DATA = 4392;

/// <summary>
/// The tag present in the reparse point buffer is invalid.
/// </summary>
const ERROR_REPARSE_TAG_INVALID = 4393;

/// <summary>
/// There is a mismatch between the tag specified in the request and the tag present in the reparse point.
/// </summary>
const ERROR_REPARSE_TAG_MISMATCH = 4394;

/// <summary>
/// Command to set the reparse point data block.
/// </summary>
const FSCTL_SET_REPARSE_POINT = 0x000900A4;

/// <summary>
/// Command to get the reparse point data block.
/// </summary>
const FSCTL_GET_REPARSE_POINT = 0x000900A8;

/// <summary>
/// Command to delete the reparse point data base.
/// </summary>
const FSCTL_DELETE_REPARSE_POINT = 0x000900AC;

/// <summary>
/// Reparse point tag used to identify mount points and junction points.
/// </summary>
const IO_REPARSE_TAG_MOUNT_POINT = 0xA0000003;

/// <summary>
/// This prefix indicates to NTFS that the path is to be treated as a non-interpreted
/// path in the virtual file system.
/// </summary>
const NonInterpretedPathPrefix = `\??\`;

//type EFileAccess  uint

var (
	EFileAccess_GenericRead uint32 = 0x80000000
	EFileAccess_GenericWrite uint32 = 0x40000000
	EFileAccess_GenericExecute uint32 = 0x20000000
	EFileAccess_GenericAll uint32 = 0x10000000
)

//type  EFileShare uint32

var (
	EFileShare_None uint32 = 0x00000000
	EFileShare_Read uint32 = 0x00000001
	EFileShare_Write uint32 = 0x00000002
	EFileShare_Delete uint32 = 0x00000004
)

//type  ECreationDisposition  uint

var (
	ECreationDisposition_New uint32 = 1
	ECreationDisposition_CreateAlways uint32 = 2
	ECreationDisposition_OpenExisting uint32 = 3
	ECreationDisposition_OpenAlways uint32 = 4
	ECreationDisposition_TruncateExisting uint32 = 5
)

//type  EFileAttributes  uint

var (
	EFileAttributes_Readonly uint32 = 0x00000001
	EFileAttributes_Hidden uint32 = 0x00000002
	EFileAttributes_System uint32 = 0x00000004
	EFileAttributes_Directory uint32 = 0x00000010
	EFileAttributes_Archive uint32 = 0x00000020
	EFileAttributes_Device uint32 = 0x00000040
	EFileAttributes_Normal uint32 = 0x00000080
	EFileAttributes_Temporary uint32 = 0x00000100
	EFileAttributes_SparseFile uint32 = 0x00000200
	EFileAttributes_ReparsePoint uint32 = 0x00000400
	EFileAttributes_Compressed uint32 = 0x00000800
	EFileAttributes_Offline uint32 = 0x00001000
	EFileAttributes_NotContentIndexed uint32 = 0x00002000
	EFileAttributes_Encrypted uint32 = 0x00004000
	EFileAttributes_Write_Through uint32 = 0x80000000
	EFileAttributes_Overlapped uint32 = 0x40000000
	EFileAttributes_NoBuffering uint32 = 0x20000000
	EFileAttributes_RandomAccess uint32 = 0x10000000
	EFileAttributes_SequentialScan uint32 = 0x08000000
	EFileAttributes_DeleteOnClose uint32 = 0x04000000
	EFileAttributes_BackupSemantics uint32 = 0x02000000
	EFileAttributes_PosixSemantics uint32 = 0x01000000
	EFileAttributes_OpenReparsePoint uint32 = 0x00200000
	EFileAttributes_OpenNoRecall uint32 = 0x00100000
	EFileAttributes_FirstPipeInstance uint32 = 0x00080000
)

type   REPARSE_DATA_BUFFER struct {
	/// <summary>
	/// Reparse point tag. Must be a Microsoft reparse point tag.
	/// </summary>
	ReparseTag           uint

	/// <summary>
	/// Size, in bytes, of the data after the Reserved member. This can be calculated by:
	/// (4 * sizeof(ushort)) + SubstituteNameLength + PrintNameLength +
	/// (namesAreNullTerminated ? 2 * sizeof(char) : 0);
	/// </summary>
	ReparseDataLength    uint16

	/// <summary>
	/// Reserved; do not use.
	/// </summary>
	Reserved             uint16

	/// <summary>
	/// Offset, in bytes, of the substitute name string in the PathBuffer array.
	/// </summary>
	SubstituteNameOffset uint16

	/// <summary>
	/// Length, in bytes, of the substitute name string. If this string is null-terminated,
	/// SubstituteNameLength does not include space for the null character.
	/// </summary>
	SubstituteNameLength uint16

	/// <summary>
	/// Offset, in bytes, of the print name string in the PathBuffer array.
	/// </summary>
	PrintNameOffset      uint16

	/// <summary>
	/// Length, in bytes, of the print name string. If this string is null-terminated,
	/// PrintNameLength does not include space for the null character.
	/// </summary>
	PrintNameLength      uint16

	/// <summary>
	/// A buffer containing the unicode-encoded path string. The path string contains
	/// the substitute name string and print name string.
	/// </summary>
	PathBuffer           []byte
}

/*
syscall.DeviceIoControl(
handle Handle,
ioControlCode uint32,
inBuffer *byte,
inBufferSize uint32,
outBuffer *byte,
outBufferSize uint32,
bytesReturned *uint32,
overlapped *Overlapped) (err error) {
}
*/
func DeviceIoControl(handle syscall.Handle, ioControlCode uint32, inBuffer *byte, inBufferSize uint32, outBuffer *byte, outBufferSize uint32, bytesReturned *uint32, overlapped *syscall.Overlapped) (err error) {
	return syscall.DeviceIoControl(handle, ioControlCode, inBuffer, inBufferSize, outBuffer, outBufferSize, bytesReturned, overlapped);
}
/*
[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)]
private static extern bool DeviceIoControl(IntPtr hDevice, uint dwIoControlCode,
IntPtr InBuffer, int nInBufferSize,
IntPtr OutBuffer, int nOutBufferSize,
out int pBytesReturned, IntPtr lpOverlapped);
*/

func CreateFile(name *uint16, access uint32, mode uint32, sa *syscall.SecurityAttributes, createmode uint32, attrs uint32, templatefile int32) (handle syscall.Handle, err error) {
	return syscall.CreateFile(name, access, mode, sa, createmode, attrs, templatefile);
}
/*
[DllImport("kernel32.dll", SetLastError = true)]
private static extern IntPtr CreateFile(
string lpFileName,
EFileAccess dwDesiredAccess,
EFileShare dwShareMode,
IntPtr lpSecurityAttributes,
ECreationDisposition dwCreationDisposition,
EFileAttributes dwFlagsAndAttributes,
IntPtr hTemplateFile);
*/
/// <summary>
/// Creates a junction point from the specified directory to the specified target directory.
/// </summary>
/// <remarks>
/// Only works on NTFS.
/// </remarks>
/// <param name="junctionPoint">The junction point path</param>
/// <param name="targetDir">The target directory</param>
/// <param name="overwrite">If true overwrites an existing reparse point or empty directory</param>
/// <exception cref="IOException">Thrown when the junction point could not be created or when
/// an existing directory was found and <paramref name="overwrite" /> if false</exception>
func Create(junctionPoint string, targetDir string, overwrite bool) bool {
	targetDir, _ = filepath.Abs(targetDir)

	var exists bool
	if exists, _ = directory.DirectoryExists(targetDir); exists == false {
		fmt.Println(targetDir + " does not exist or is not a directory.")
		return false
		//log(targetDir + " does not exist or is not a directory.");
		//throw
		//new
		//IOException("Target path does not exist or is not a directory.");
		//return false;
	}

	if exists, _ = directory.DirectoryExists(junctionPoint); exists == false {
		if !overwrite {
			fmt.Println(junctionPoint + " already exists and overwrite parameter is false.")
			//log(junctionPoint + " already exists and overwrite parameter is false.");
			//throw
			//new
			//IOException("Directory already exists and overwrite parameter is false.");
			return false;
		}
	} else {
		os.MkdirAll(junctionPoint, 0777);

		//Directory.CreateDirectory(junctionPoint);
	}

	handle := OpenReparsePoint(junctionPoint, EFileAccess_GenericWrite)
	//{
	targetDir, _ = filepath.Abs(targetDir);
	targetDirBytes := []byte(NonInterpretedPathPrefix + targetDir)//Encoding.Unicode.GetBytes(NonInterpretedPathPrefix + Path.GetFullPath(targetDir));

	var reparseDataBuffer REPARSE_DATA_BUFFER = REPARSE_DATA_BUFFER{}

	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT
	reparseDataBuffer.ReparseDataLength = uint16(len(targetDirBytes) + 12)
	reparseDataBuffer.SubstituteNameOffset = 0
	reparseDataBuffer.SubstituteNameLength = uint16(len(targetDirBytes))
	reparseDataBuffer.PrintNameOffset = uint16(len(targetDirBytes) + 2)
	reparseDataBuffer.PrintNameLength = 0;
	reparseDataBuffer.PathBuffer = targetDirBytes[0:len(targetDirBytes) - 1]//Array.Copy(targetDirBytes, reparseDataBuffer.PathBuffer, targetDirBytes.Length);

	//var inBufferSize int = unsafe.Sizeof(reparseDataBuffer)//int inBufferSize = Marshal.SizeOf(reparseDataBuffer);
	//var  inBuffer *[]byte=&[inBufferSize]byte//IntPtr inBuffer = Marshal.AllocHGlobal(inBufferSize);

	//try
	//{
	inBuffer := &bytes.Buffer{}
	err := binary.Write(inBuffer, binary.BigEndian, reparseDataBuffer)
	if err != nil {
		panic("")
	}
	//Marshal.StructureToPtr(reparseDataBuffer, inBuffer, false);

	var bytesReturned *uint32;

	inBufferBytes := inBuffer.Bytes();
	var zeroByte *byte = &(make([]byte, 1))[0]

	var overlapped *syscall.Overlapped = &syscall.Overlapped{}

	result := DeviceIoControl(handle, FSCTL_SET_REPARSE_POINT,
		&inBufferBytes[0], uint32(len(targetDirBytes) + 20), zeroByte, 0, bytesReturned, overlapped);

	if result != nil {
		panic("Unable to create junction point.")
	}
	//ThrowLastWin32Error("Unable to create junction point.");
	//}
	//finally
	//{
	//Marshal.FreeHGlobal(inBuffer);
	//}
	//}
	return true
}

/// <summary>
/// Deletes a junction point at the specified source directory along with the directory itself.
/// Does nothing if the junction point does not exist.
/// </summary>
/// <remarks>
/// Only works on NTFS.
/// </remarks>
/// <param name="junctionPoint">The junction point path</param>
func Delete(junctionPoint string) {
	if exist, _ := directory.DirectoryExists(junctionPoint); exist == false {
		//if (!Directory.Exists(junctionPoint))
		//if (File.Exists(junctionPoint))
		if _, err := os.Stat(junctionPoint); os.IsNotExist(err) {
			// path/to/whatever does not exist
			//throw new IOException("Path is not a junction point.");
			panic("Path is not a junction point.")
		}
		return;
	}

	handle := OpenReparsePoint(junctionPoint, EFileAccess_GenericWrite)

	reparseDataBuffer := REPARSE_DATA_BUFFER{}

	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT
	reparseDataBuffer.ReparseDataLength = 0

	reparseDataBuffer.PathBuffer = make([]byte, 16368)

	//TODO 改
	//var inBufferSize int = int(unsafe.Sizeof(reparseDataBuffer))//Marshal.SizeOf(reparseDataBuffer);
	inBuffer := make([]byte, 10) //= &[10]byte //IntPtr inBuffer = Marshal.AllocHGlobal(inBufferSize);
	//try
	//{
	buf := &bytes.Buffer{}
	err := binary.Write(buf, binary.BigEndian, reparseDataBuffer)
	if err != nil {
		panic(err)
	}
	//Marshal.StructureToPtr(reparseDataBuffer, inBuffer, false);

	var bytesReturned *uint32;

	var zeroByte *byte = &(make([]byte, 1))[0]

	var overlapped *syscall.Overlapped = &syscall.Overlapped{}

	err = DeviceIoControl(handle, FSCTL_DELETE_REPARSE_POINT,
		&inBuffer[0], 8, zeroByte, 0, bytesReturned, overlapped);

	if err != nil {
		panic("Unable to delete junction point.")
	}
	//ThrowLastWin32Error("Unable to delete junction point.");
	//}
	//finally
	//{
	//Marshal.FreeHGlobal(inBuffer);
	//}

	//try
	//{
	err = os.RemoveAll(junctionPoint)
	if err != nil {
		panic("Unable to delete junction point.")
	}
	//Directory.Delete(junctionPoint);
	//}
	//catch (IOException ex)
	//{
	//throw new IOException("Unable to delete junction point.", ex);
	//}

}

/// <summary>
/// Determines whether the specified path exists and refers to a junction point.
/// </summary>
/// <param name="path">The junction point path</param>
/// <returns>True if the specified path represents a junction point</returns>
/// <exception cref="IOException">Thrown if the specified path is invalid
/// or some other error occurs</exception>
func Exists(path string) bool {
	if exists, _ := directory.DirectoryExists(path); exists == false {
		return false
	}

	//if (! Directory.Exists(path))
	//		return false;
	///using (SafeFileHandle handle = OpenReparsePoint(path, EFileAccess.GenericRead))
	handle := OpenReparsePoint(path, EFileAccess_GenericRead)
	//{
	target := InternalGetTarget(handle)
	return len(target) > 0
	//}
}

/// <summary>
/// Gets the target of the specified junction point.
/// </summary>
/// <remarks>
/// Only works on NTFS.
/// </remarks>
/// <param name="junctionPoint">The junction point path</param>
/// <returns>The target of the junction point</returns>
/// <exception cref="IOException">Thrown when the specified path does not
/// exist, is invalid, is not a junction point, or some other error occurs</exception>
func GetTarget(junctionPoint string) string {
	handle := OpenReparsePoint(junctionPoint, EFileAccess_GenericRead)
	target := InternalGetTarget(handle);
	if len(target) <= 0 {
		panic("Path is not a junction point.")
	}
	//throw new IOException("Path is not a junction point.");
	return target;

}

func InternalGetTarget(handle syscall.Handle) string {
	var reparseDataBuffer REPARSE_DATA_BUFFER
	var outBufferSize uint32 = uint32(unsafe.Sizeof(reparseDataBuffer))

	outBufferByte:=make([]byte, outBufferSize)
	var outBuffer *byte = &outBufferByte[0]

	var bytesReturned *uint32;

	var zeroByte *byte = &(make([]byte, 1))[0]

	var overlapped *syscall.Overlapped = &syscall.Overlapped{}

	result := DeviceIoControl(handle, FSCTL_GET_REPARSE_POINT,
		zeroByte, 0, outBuffer, outBufferSize, bytesReturned, overlapped);

	fmt.Println(result.Error())
	//
	//if result != nil {
	//	lasterr := syscall.GetLastError();
	//	if  lasterr!=nil && lasterr.Error() == string(ERROR_NOT_A_REPARSE_POINT) {
	//		fmt.Println("Unable to open reparse point.")
	//		return ""
	//	}
	//	panic("Unable to open reparse point.")
        //
	//}

	//REPARSE_DATA_BUFFER reparseDataBuffer = (REPARSE_DATA_BUFFER)Marshal.PtrToStructure(outBuffer, typeof(REPARSE_DATA_BUFFER));
	//var reparseDataBuffer REPARSE_DATA_BUFFER = REPARSE_DATA_BUFFER{}




	err := binary.Read(bytes.NewReader(outBufferByte), binary.BigEndian, &reparseDataBuffer)
	if err != nil {
		panic(err)
	}

	if reparseDataBuffer.ReparseTag != IO_REPARSE_TAG_MOUNT_POINT {
		return "";
	}

	//string targetDir = Encoding.Unicode.GetString(
	//	reparseDataBuffer.PathBuffer,
	//	reparseDataBuffer.SubstituteNameOffset,
	//	reparseDataBuffer.SubstituteNameLength);
	var targetDir string = string(reparseDataBuffer.PathBuffer[reparseDataBuffer.SubstituteNameOffset:reparseDataBuffer.SubstituteNameOffset + reparseDataBuffer.SubstituteNameLength - 1])

	if strings.HasPrefix(targetDir, NonInterpretedPathPrefix) {
		targetDir = targetDir[len(NonInterpretedPathPrefix):]
	}
	//if (targetDir.StartsWith(NonInterpretedPathPrefix))
	//	targetDir = targetDir.Substring(NonInterpretedPathPrefix.Length);

	return targetDir

	//Marshal.FreeHGlobal(outBuffer);

}

func OpenReparsePoint(reparsePoint string, accessMode uint32) syscall.Handle {
	sa :=syscall.SecurityAttributes{}
	reparsePointUint64, _ := strconv.ParseUint(reparsePoint, 16, 16)
	reparsePointUint16:=uint16(reparsePointUint64)
	handle, err := CreateFile(
		&reparsePointUint16,
		accessMode,
		(EFileShare_Read | EFileShare_Write | EFileShare_Delete),
		&syscall.SecurityAttributes{Length:uint32(unsafe.Sizeof(sa)), InheritHandle:0},
		ECreationDisposition_OpenExisting,
		EFileAttributes_BackupSemantics | EFileAttributes_OpenReparsePoint,
		0)

	fmt.Println(err)
	//SafeFileHandle reparsePointHandle = new SafeFileHandle(CreateFile(reparsePoint, accessMode,EFileShare.Read | EFileShare.Write | EFileShare.Delete,
	//	IntPtr.Zero, ECreationDisposition.OpenExisting,EFileAttributes.BackupSemantics | EFileAttributes.OpenReparsePoint, IntPtr.Zero), true);

	if lasterr := syscall.GetLastError(); lasterr != nil {
		panic("Unable to open reparse point.")
	}
	//if (Marshal.GetLastWin32Error() != 0)
	//	ThrowLastWin32Error("Unable to open reparse point.");

	return handle
}




//private static void ThrowLastWin32Error(string message)
//{
//	throw new IOException(message, Marshal.GetExceptionForHR(Marshal.GetHRForLastWin32Error()));
//}


